### Отчет по работе с Dockerfile

#### Задание

1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены
3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат
4. В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.


### 1. Пример "плохого" Dockerfile

```dockerfile
FROM ubuntu:latest

RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y python3-pip
RUN pip3 install flask

COPY . /app

WORKDIR /app

CMD ["python3", "app.py"]
```

#### Разбор плохих практик:

1. **Использование `latest` в `FROM`**  
   Это приведет к тому, что образ станет нестабильным, поскольку этот тег всегда ссылается на последнюю доступную версию. Если что-то пойдёт не так в рабочей среде, мы не сможем определить, какая версия наших релизов вызывает проблему.

2. **Много отдельных `RUN` команд**  
   Каждая такая команда создаёт новый слой в образе, увеличивая его размер и снижая эффективность. Это может замедлить сборку и увеличить потребление места.

3. **Неявная установка зависимостей**  
   В примере с установкой `python3` и `pip3` команды `apt-get install` не очищают кеш пакетов после установки, что увеличивает размер итогового образа. Кроме того, отсутствует фиксация версий пакетов.

### 2. Пример "хорошего" Dockerfile

```dockerfile
FROM ubuntu:20.04

RUN apt-get update && \
    apt-get install -y python3 python3-pip && \
    pip3 install flask && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

COPY . /app

WORKDIR /app

CMD ["python3", "app.py"]
```

#### Разбор исправленных практик:

1. **Использование конкретной версии образа**  
   В хорошей версии используется `ubuntu:20.04`, а не `ubuntu:latest`. Это фиксирует версию базового образа, что делает поведение образа предсказуемым и стабильным при последующих сборках.

2. **Объединение команд `RUN`**  
   Команды RUN объединены в один блок через && для уменьшения количества слоев, что снижает размер конечного образа и ускоряет его сборку.

3. **Очистка кеша и ненужных файлов**  
   Можно воспользоваться командой apt-get clean и удалить кеш пакетов (/var/lib/apt/lists/*). Это позволит сделать образ более лёгким и эффективным.

### 3. Две плохие практики при работе с контейнерами

#### 1. **Запуск контейнера с привилегиями root**  
Это небезопасно. Так злоумышленник может получит доступ к контейнеру и сможет выполнить команды от имени root, что открывает путь к атаке на основную систему.

Лучше создавать и использовать учётные записи без прав администратора для запуска приложений внутри контейнера. В Dockerfile можно добавить следующие строки:

```dockerfile
RUN useradd -m nonrootuser
USER nonrootuser
```

#### 2. **Отсутствие ограничения на использование ресурсов**  
Без ограничений один контейнер может использовать все ресурсы хоста, нарушая работу других сервисов.

Чтобы ограничить потребление ресурсов контейнером, можно использовать флаги --memory и --cpus:

```bash
docker run --memory="512m" --cpus="1" your_image
```

### 4. Заключение

Применение правильных методов при создании Dockerfile и работе с контейнерами позволяет получить более эффективные и защищённые образы, которые не создают нагрузку на систему и работают предсказуемо в разных средах.