### Отчет по работе с Docker Compose

#### Задание

1. Написать “плохой” Docker compose файл, в котором есть не менее трех “bad practices” по их написанию
2. Написать “хороший” Docker compose файл, в котором эти плохие практики исправлены
3. В Readme описать каждую из плохих практик в плохом файле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат
4. После предыдущих пунктов в хорошем файле настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети. В отчете описать, как этого добились и кратко объяснить принцип такой изоляции



### 1. Пример "плохого" Docker compose файла

```yaml
version: '3.8'

services:
  db:
    image: postgres:latest 
    environment:
      POSTGRES_USER: postgres_user 
      POSTGRES_PASSWORD: postgres_password
      POSTGRES_DB: postgres_database
    restart: always 

  web:
    image: myapp:latest 
    ports:
      - "80:80"
    environment:
      DEBUG: "True" 
    depends_on:
      - db

```

#### Разбор плохих практик:

1. **Использование `latest`**  
   Аналогичная ситуация, как и с dockerfile. Если хочется избежать проблем с несовместимостью версий и неожиданных сбоев при деплое, то лучше отказаться от этого.

2. **Хранение секретов в docker compose**  
   Если хранить конфиденциальных данных, таких как POSTGRES_PASSWORD и POSTGRES_USER, прямо в docker-compose.yml, это может привести к утечке данных

3. **Включение DEBUG=True в Production**  
   Выводит дополнительную информацию, включая внутренние переменные и ошибки, что угрожает безопасности приложения.

4. **restart: always**  
   Перезапускает контейнер при любой ошибке, что может скрыть серьезные сбои и приводить к бесконечным перезапускам.

5. **Отсутствие ограничения ресурсов**
   Без ограничения ресурсов контейнер может использовать все доступные ресурсы хоста, что приводит к перегрузке системы и замедлению других контейнеров.


### 2. Пример "хорошего" Docker compose файла

```yaml
version: '3.8'

services:
  db:
    image: postgres:17 
    env_file: .env 
    restart: on-failure 
    networks:
      - db-net

  web:
    image: myapp:1.0.0 
    ports:
      - "80:80"
    env_file: .env 
    depends_on:
      - db
    deploy:
      resources:
        limits:
          cpus: "0.5" 
          memory: "512M"
    networks:
      - web-net

networks:
  db-net:
    driver: bridge
  web-net:
    driver: bridge

```

#### Разбор исправленных практик:

1. **Использование конкретной версии образа**  
    Для сервиса db используется конкретная версия postgres:17, а для web — myapp:1.0.0. Каждый раз при запуске будет использоваться именно эта версия. Это обеспечивает стабильную и предсказуемую работу.

2. **Вынос секретов**  
   Секреты вынесены в файл .env, который не включается в репозиторий (добавляется в .gitignore).

3. **Убрать DEBUG=True**  
   Убрав DEBUG=True и загрузив конфигурации из .env, приложение не выводит лишнюю информацию в логах, что делает его безопаснее.

4. **restart: on-failure**   
   Позволяет перезапускать контейнер только при программной ошибке, сохраняя системные ресурсы и предотвращая бесконечные перезапуски при серьёзных проблемах.

5. **Ограничения ресурсов**
   Указание лимита процессора и памяти (cpus: "0.5", memory: "512M") делает потребление ресурсов контейнером предсказуемым и предотвращает утечки.

### 3. Сетевая настройка Docker Compose проекта

Чтобы обеспечить изоляцию сервисов db и web, в docker-compose_good.yml созданы отдельные сети:

- db-net для db
- web-net для web

Контейнеры db и web не видят друг друга по сети, так как они подключены к разным виртуальным сетям Docker (db-net и web-net). Эта изоляция повышает безопасность и позволяет сервисам работать независимо, исключая лишние сетевые соединения.

### 4. Заключение

Использование хороших практик при написании Docker Compose файлов и настройке контейнеров помогает обеспечить безопасность, стабильность и предсказуемое поведение приложений.